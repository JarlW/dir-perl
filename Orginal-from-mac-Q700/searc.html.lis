  <TITLE>s/-Man</TITLE>s/PATTERN/REPLACEMENT/egimosx			Searches a string for a pattern, and if found, replaces that pattern with the replacement text and returns the number of substitutions made.  Otherwise it returns false (specifically, the empty string).		If no string is specified via the =~ or !~ operator, the $_ variable is searched and modified.  (The string specified with =~ must be a scalar variable, an array element, a hash element, or an assignment to one of those, i.e., an lvalue.)		If the delimiter chosen is single quote, no variable interpolation is done on either the PATTERN or the REPLACEMENT.  Otherwise, if the PATTERN contains a $ that looks like a variable rather than an end-of-string test, the variable will be interpolated into the pattern at run-time.  If you want the pattern compiled only once the first time the variable is interpolated, use the /o option.  If the pattern evaluates to a null string, the last successfully executed regular expression is used instead.  See in the perlre manpage for further explanation on these. See in the perllocale manpage for discussion of additional considerations which apply when use locale is in effect.		Options are:		    e   Evaluate the right side as an expression.		    g   Replace globally, i.e., all occurrences.		    i   Do case-insensitive pattern matching.		    m   Treat string as multiple lines.		    o   Compile pattern only once.		    s   Treat string as single line.		    x   Use extended regular expressions.		Any non-alphanumeric, non-whitespace delimiter may replace the slashes.  If single quotes are used, no interpretation is done on the replacement string (the /e modifier overrides this, however).  Unlike Perl 4, Perl 5 treats backticks as normal delimiters; the replacement text is not evaluated as a command.  If the PATTERN is delimited by bracketing quotes, the REPLACEMENT has its own pair of quotes, which may or may not be bracketing quotes, e.g., s(foo)(bar) or s<foo>/bar/.  A /e will cause the replacement portion to be interpreter as a full-fledged Perl expression and eval()ed right then and there.  It is, however, syntax checked at compile-time.		Examples:		    s/\bgreen\b/mauve/g;                # don't change wintergreen				    $path =~ s|/usr/bin|/usr/local/bin|;				    s/Login: $foo/Login: $bar/; # run-time pattern				    ($foo = $bar) =~ s/this/that/;				    $count = ($paragraph =~ s/Mister\b/Mr./g);				    $_ = 'abc123xyz';		    s/\d+/$&*2/e;               # yields 'abc246xyz'		    s/\d+/sprintf("%5d",$&)/e;  # yields 'abc  246xyz'		    s/\w/$& x 2/eg;             # yields 'aabbcc  224466xxyyzz'				    s/%(.)/$percent{$1}/g;      # change percent escapes; no /e		    s/%(.)/$percent{$1} || $&/ge;       # expr now, so /e		    s/^=(\w+)/&pod($1)/ge;      # use function call				    # /e's can even nest;  this will expand		    # simple embedded variables in $_		    s/(\$\w+)/$1/eeg;				    # Delete C comments.		    $program =~ s {		        /\*     # Match the opening delimiter.		        .*?     # Match a minimal number of characters.		        \*/     # Match the closing delimiter.		    } []gsx;				    s/^\s*(.*?)\s*$/$1/;        # trim white space				    s/([^ ]*) *([^ ]*)/$2 $1/;  # reverse 1st two fields		Note the use of $ instead of \ in the last example.  Unlike sed, we use the \<digit> form in only the left hand side. Anywhere else it's $<digit>.		Occasionally, you can't use just a /g to get all the changes to occur.  Here are two common cases:		    # put commas in the right places in an integer		    1 while s/(.*\d)(\d\d\d)/$1,$2/g;      # perl4		    1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/g;  # perl5				    # expand tabs to 8-column spacing		    1 while s/\t+/' ' x (length($&)*8 - length($`)%8)/e;